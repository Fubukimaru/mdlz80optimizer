; Author: Santiago Ontañón; - Patterns are separated by a blank line; - Patterns suggested by others are credited to them below. ; - If you do a pull request with more patterns, please credit yourself in a comment before the pattern.; thanks to pgimeno for noticing the needed constraintpattern: cp nn; jp c,mm; jp z,mm -> cp nn+1; jp c,mm0: cp ?const11: jp c,?const22: jp z,?const2replacement:0: cp ?const1+11: jp c,?const2constraints:notEqual(?const1,255); thanks to pgimeno for noticing the needed constraintpattern: cp nn; jr c,mm; jr z,mm -> cp nn+1; jr c,mm0: cp ?const11: jr c,?const22: jr z,?const2replacement:0: cp ?const1+11: jr c,?const2constraints:notEqual(?const1,255)pattern: cp 0 -> or a0: cp 0replacement:0: or apattern: cp 1 -> dec a0: cp 1replacement:0: dec aconstraints:regNotUsed(0,A)pattern: cp 255 -> inc a0: cp 255replacement:0: inc aconstraints:regNotUsed(0,A)pattern: ld a,0 -> xor a0: ld a,0replacement:0: xor aconstraints:flagsNotUsed(0,S,Z,H,P/V,N,C)pattern: srl a; srl a; srl a -> rrca; rrca; rrca; and #1f0: srl a1: srl a2: srl areplacement:0: rrca1: rrca2: rrca2: and #1fpattern: unused ld reg,?0: ld ?reg,?anyreplacement:constraints:regNotUsed(0,?reg)pattern: pop bc; ld c,b; ld e,c -> pop de0: pop bc1: ld d,b2: ld e,creplacement:0: pop deconstraints:regNotUsed(2,bc)pattern: pop bc; ld h,b; ld l,c -> pop hl0: pop bc1: ld h,b2: ld l,creplacement:0: pop hlconstraints:regNotUsed(2,bc)pattern: 0: ld a,(nn); inc a; ld (nn),a ->  ld hl,nn; inc (hl)0: ld a,(?const1)1: inc a2: ld (?const1),areplacement:0: ld hl,?const11: inc (hl)constraints:regNotUsed(2,A,HL)pattern: ld a,(nn); inc a; ld (nn),a ->  ld hl,nn; inc (hl); ld a,(hl)0: ld a,(?const1)1: inc a2: ld (?const1),areplacement:0: ld hl,?const11: inc (hl)2: ld a,(hl)constraints:regNotUsed(2,HL)pattern: ld b,n; ld c,m -> ld bc m+n*2560: ld b,?const11: ld c,?const2replacement:0: ld bc,?const2 + 256 * (?const1)pattern: ld c,m; ld b,n -> ld bc m+n*2560: ld c,?const21: ld b,?const1replacement:0: ld bc,?const2 + 256 * (?const1)pattern: ld d,n; ld e,m -> ld de,m+n*2560: ld d,?const11: ld e,?const2replacement:0: ld de,?const2 + 256 * (?const1)pattern: ld e,m; ld d,n -> ld de,m+n*2560: ld e,?const21: ld d,?const1replacement:0: ld de,?const2 + 256 * (?const1)pattern: ld h,n; ld l,m -> ld hl,m+n*2560: ld h,?const11: ld l,?const2replacement:0: ld hl,?const2 + 256 * (?const1)pattern: ld l,m; ld h,n -> ld hl,m+n*2560: ld l,?const21: ld h,?const1replacement:0: ld hl,?const2 + 256 * (?const1)pattern: ld a,n; ld (hl),a -> ld (hl),n0: ld a,?const11: ld (hl),areplacement:0: ld (hl),?const1constraints:regNotUsed(1,A)pattern: dec b; jr nz,label -> djnz label0: dec b1: jr nz,?const1replacement:0: djnz ?const1pattern: ld a,(hl); lde (de),a; inc hl; inc de -> ldi0: ld a,(hl)1: ld (de),a2: inc hl3: inc dereplacement:0: ldiconstraints:regNotUsed(3,A,BC); thanks to pgimeno for suggesting this permutationpattern: ld a,(hl); inc hl; lde (de),a; inc de -> ldi0: ld a,(hl)2: inc hl1: ld (de),a3: inc dereplacement:0: ldiconstraints:regNotUsed(3,A,BC)pattern: ld a,(hl); lde (de),a; inc de; inc hl; -> ldi0: ld a,(hl)1: ld (de),a3: inc de2: inc hlreplacement:0: ldiconstraints:regNotUsed(3,A,BC)pattern: ld a,(hl); lde (de),a; inc hl; inc de -> ldi; inc bc0: ld a,(hl)1: ld (de),a2: inc hl3: inc dereplacement:0: ldi1: inc bcconstraints:regNotUsed(3,A); thanks to pgimeno for suggesting this permutationpattern: ld a,(hl); inc hl; lde (de),a; inc de -> ldi; inc bc0: ld a,(hl)2: inc hl1: ld (de),a3: inc dereplacement:0: ldi1: inc bcconstraints:regNotUsed(3,A)pattern: ld a,(hl); lde (de),a; inc de; inc hl; -> ldi0: ld a,(hl)1: ld (de),a3: inc de2: inc hlreplacement:0: ldi1: inc bcconstraints:regNotUsed(3,A)          pattern: ld de,nn; or a; sbc hl,de -> ld de,-nn; add hl,de0: ld de,?const11: or a2: sbc hl,dereplacement:0: ld de,-?const11: add hl,de ; thanks to grauw for suggesting this variationpattern: ld de,nn; and a; sbc hl,de -> ld de,-nn; add hl,de0: ld de,?const11: and a2: sbc hl,dereplacement:0: ld de,-?const11: add hl,de pattern: neg; add a,n -> cpl; add a,n+10: neg1: add a,?const1replacement:0: cpl1: add a,?const1+1pattern: xor 255 -> cpl0: xor 255replacement:0: cplconstraints:flagNotUsed(0,S,Z,P/V,C)pattern: ld a,reg; neg -> xor a; sub reg0: ld a,?reg1: negreplacement:0: xor a1: sub ?regpattern: ld a,reg; sub n; neg -> ld a,n; sub reg0: ld a,?reg1: sub ?const2: negreplacement:0: ld a,?const1: sub ?regpattern: sla l; rl h -> add hl,hl0: sla l1: rl hreplacement:0: add hl,hlconstraints:flagsNotUsed(1,S,Z,P/V,C); thanks to grauw for suggesting this patternpattern: sla a -> add a,a0: sla areplacement:0: add a,aconstraints:flagsNotUsed(0,H,P/V)