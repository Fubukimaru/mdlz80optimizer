; Author: Santiago Ontañón
; - Patterns are separated by a blank line
; - Patterns suggested by others are credited to them below.
; - If you do a pull request with more patterns, please credit yourself in a comment before the pattern.

; Notes:
; - variables must start with the following prefixes:
; - ?const: for example ?const1, ?constant, etc. These match with constant expressions, like "(VAR+2)/$", or "1".
; - ?reg: for example ?reg1, ?regpair, etc. These match with register names.
; - ?any: for example ?any, ?any1. These match with anything.
; Notice the numbers in front of each line int he pattern and the replacement. The order does not matter as long as numbers are unique.
; These are used to match lines from pattern to replacement. Any number appearing in pattern, and not in replacement will be deleted.
; The optimization will be reported to the line in pattern with number 0 (at least one line must have number 0)

; thanks to pgimeno for noticing the needed constraint
pattern: Replace cp ?const1; jp c,?const2; jp z,?const2 with cp ?const1+1; jp c,?const2
0: cp ?const1
1: jp c,?const2
2: jp z,?const2
replacement:
0: cp ?const1+1
1: jp c,?const2
constraints:
notEqual(?const1,255)

; thanks to pgimeno for noticing the needed constraint
pattern: Replace cp ?const1; jr c,?const2; jr z,?const2 with cp ?const1+1; jr c,?const2
0: cp ?const1
1: jr c,?const2
2: jr z,?const2
replacement:
0: cp ?const1+1
1: jr c,?const2
constraints:
notEqual(?const1,255)

pattern: Replace cp 0 with or a
0: cp 0
replacement:
0: or a

pattern: Replace cp 1 with dec a
0: cp 1
replacement:
0: dec a
constraints:
regsNotUsedAfter(0,A)

pattern: Replace cp 255 with inc a
0: cp 255
replacement:
0: inc a
constraints:
regsNotUsedAfter(0,A)

pattern: Replace ld a,0 with xor a
0: ld a,0
replacement:
0: xor a
constraints:
flagsNotUsedAfter(0,S,Z,H,P/V,N,C)

pattern: Replace srl a; srl a; srl a with rrca; rrca; rrca; and #1f
0: srl a
1: srl a
2: srl a
replacement:
0: rrca
1: rrca
2: rrca
2: and #1f

pattern: Remove unused ld ?reg,?any
0: ld ?reg,?any
replacement:
constraints:
regsNotUsedAfter(0,?reg)

pattern: Replace pop ?regpair1; ld ?regpair2h,?regpair1h; ld ?regpair2l,?regpair1l with pop ?regpair2
0: pop ?regpair1
1: ld ?regpair2h,?regpair1h
2: ld ?regpair2l,?regpair1l
replacement:
0: pop ?regpair2
constraints:
in(?regpair1,BC,DE,HL)
regpair(?regpair1,?regpair1h,?regpair1l)
regpair(?regpair2,?regpair2h,?regpair2l)
in(?regpair2,BC,DE,HL)
regsNotUsedAfter(2,?regpair1)

pattern: Replace pop ?regpair1; ld ?regpair2l,?regpair1l; ld ?regpair2h,?regpair1h with pop ?regpair2
0: pop ?regpair1
2: ld ?regpair2l,?regpair1l
1: ld ?regpair2h,?regpair1h
replacement:
0: pop ?regpair2
constraints:
in(?regpair1,BC,DE,HL)
regpair(?regpair1,?regpair1h,?regpair1l)
regpair(?regpair2,?regpair2h,?regpair2l)
in(?regpair2,BC,DE,HL)
regsNotUsedAfter(2,?regpair1)

pattern: Replace 0: ld a,(?const1); inc a; ld (?const1),a with  ld hl,?const1; inc (hl)
0: ld a,(?const1)
1: inc a
2: ld (?const1),a
replacement:
0: ld hl,?const1
1: inc (hl)
constraints:
regsNotUsedAfter(2,A,HL)

pattern: Replace ld a,(?const1); inc a; ld (?const1),a with  ld hl,?const1; inc (hl); ld a,(hl)
0: ld a,(?const1)
1: inc a
2: ld (?const1),a
replacement:
0: ld hl,?const1
1: inc (hl)
2: ld a,(hl)
constraints:
regsNotUsedAfter(2,HL)

pattern: Replace ld ?regpair1h,?const1; ld ?regpair1l,?const2 with ld ?regpair1,((?const2) & #ff) + ((?const1) << 8)
0: ld ?regpair1h,?const1
1: ld ?regpair1l,?const2
replacement:
0: ld ?regpair1,((?const2) & #ff) + ((?const1) << 8)
constraints:
regpair(?regpair1,?regpair1h,?regpair1l)

pattern: Replace ld ?regpair1l,?const2; ld ?regpair1h,?const1 with ld ?regpair1,((?const2) & #ff) + ((?const1) << 8)
0: ld ?regpair1l,?const2
1: ld ?regpair1h,?const1
replacement:
0: ld ?regpair1,((?const2) & #ff) + ((?const1) << 8)
constraints:
regpair(?regpair1,?regpair1h,?regpair1l)

pattern: Replace ld a,?const1; ld (hl),a with ld (hl),?const1
0: ld a,?const1
1: ld (hl),a
replacement:
0: ld (hl),?const1
constraints:
regsNotUsedAfter(1,A)

pattern: Replace dec b; jr nz,label with djnz label
0: dec b
1: jr nz,?const1
replacement:
0: djnz ?const1

pattern: Replace ld a,(hl); lde (de),a; inc hl; inc de with ldi
0: ld a,(hl)
1: ld (de),a
2: inc hl
3: inc de
replacement:
0: ldi
constraints:
regsNotUsedAfter(3,A,BC)

; thanks to pgimeno for suggesting this permutation
pattern: Replace ld a,(hl); inc hl; lde (de),a; inc de with ldi
0: ld a,(hl)
2: inc hl
1: ld (de),a
3: inc de
replacement:
0: ldi
constraints:
regsNotUsedAfter(3,A,BC)

pattern: Replace ld a,(hl); lde (de),a; inc de; inc hl; with ldi
0: ld a,(hl)
1: ld (de),a
3: inc de
2: inc hl
replacement:
0: ldi
constraints:
regsNotUsedAfter(3,A,BC)

pattern: Replace ld a,(hl); lde (de),a; inc hl; inc de with ldi; inc bc
0: ld a,(hl)
1: ld (de),a
2: inc hl
3: inc de
replacement:
0: ldi
1: inc bc
constraints:
regsNotUsedAfter(3,A)

; thanks to pgimeno for suggesting this permutation
pattern: Replace ld a,(hl); inc hl; lde (de),a; inc de with ldi; inc bc
0: ld a,(hl)
2: inc hl
1: ld (de),a
3: inc de
replacement:
0: ldi
1: inc bc
constraints:
regsNotUsedAfter(3,A)

pattern: Replace ld a,(hl); lde (de),a; inc de; inc hl; with ldi
0: ld a,(hl)
1: ld (de),a
3: inc de
2: inc hl
replacement:
0: ldi
1: inc bc
constraints:
regsNotUsedAfter(3,A)

pattern: Replace ld ?regpair,?const1; or a; sbc hl,?regpair with ld ?regpair,-(?const1); add hl,regpair
0: ld ?regpair,?const1
1: or a
2: sbc hl,?regpair
replacement:
0: ld ?regpair,-(?const1)
1: add hl,?regpair
constraints:
in(?regpair,bc,de)

; thanks to grauw for suggesting this variation
pattern: Replace ld ?regpair,?const1; and a; sbc hl,?regpair with ld ?regpair,-(?const1); add hl,regpair
0: ld ?regpair,?const1
1: and a
2: sbc hl,?regpair
replacement:
0: ld ?regpair,-(?const1)
1: add hl,?regpair
constraints:
in(?regpair,bc,de)

pattern: Replace neg; add a,?const1 with cpl; add a,?const1+1
0: neg
1: add a,?const1
replacement:
0: cpl
1: add a,?const1+1

pattern: Replace xor 255 with cpl
0: xor 255
replacement:
0: cpl
constraints:
flagsNotUsedAfter(0,S,Z,P/V,C)

pattern: Replace ld a,?reg; neg with xor a; sub ?reg
0: ld a,?reg
1: neg
replacement:
0: xor a
1: sub ?reg

pattern: Replace ld a,?reg; sub ?const; neg with ld a,?const; sub ?reg
0: ld a,?reg
1: sub ?const
2: neg
replacement:
0: ld a,?const
1: sub ?reg

pattern: Replace sla l; rl h with add hl,hl
0: sla l
1: rl h
replacement:
0: add hl,hl
constraints:
flagsNotUsedAfter(1,S,Z,P/V,C)

; thanks to grauw for suggesting this pattern
pattern: Replace sla a with add a,a
0: sla a
replacement:
0: add a,a
constraints:
flagsNotUsedAfter(0,H,P/V)

; theNestruo
pattern: Replace call ?const; ret with jp ?const
0: call ?const
1: ret
replacement:
0: jp ?const

pattern: Replace and 1; cp 1; jr z,?const with rra; jr nz,?const
0: and 1
1: cp 1
2: jr z,?const
replacement:
0: rra
1: jr c,?const
constraints:
regsNotUsedAfter(2,A)

pattern: Replace and 1; cp 1; jp z,?const with rra; jp nz,?const
0: and 1
1: cp 1
2: jp z,?const
replacement:
0: rra
1: jp c,?const
constraints:
regsNotUsedAfter(2,A)

pattern: Replace and 1; cp 1; call z,?const with rra; call nz,?const
0: and 1
1: cp 1
2: call z,?const
replacement:
0: rra
1: call c,?const
constraints:
regsNotUsedAfter(2,A)

pattern: Replace and 1; cp 1; jr z,?const with and 1; jr nz,?const
0: and 1
1: cp 1
2: jr z,?const
replacement:
0: and 1
1: jr nz,?const

pattern: Replace and 1; cp 1; jp z,?const with and 1; jp nz,?const
0: and 1
1: cp 1
2: jp z,?const
replacement:
0: and 1
1: jp nz,?const

pattern: Replace and 1; cp 1; call z,?const with and 1; call nz,?const
0: and 1
1: cp 1
2: call z,?const
replacement:
0: and 1
1: call nz,?const

pattern: Replace bit 0,a; jr z,?const with rra; jr nc,?const
0: bit 0,a
1: jr z,?const
replacement:
0: rra
1: jr nc,?const
constraints:
regsNotUsedAfter(1,A)

pattern: Replace bit 7,a; jr z,?const with rla; jr nc,?const
0: bit 7,a
1: jr z,?const
replacement:
0: rla
1: jr nc,?const
constraints:
regsNotUsedAfter(1,A)

pattern: Replace bit 0,a; jp z,?const with rra; jp nc,?const
0: bit 0,a
1: jp z,?const
replacement:
0: rra
1: jp nc,?const
constraints:
regsNotUsedAfter(1,A)

pattern: Replace bit 7,a; jp z,?const with rla; jp nc,?const
0: bit 7,a
1: jp z,?const
replacement:
0: rla
1: jp nc,?const
constraints:
regsNotUsedAfter(1,A)

pattern: Replace bit 0,a; call z,?const with rra; call nc,?const
0: bit 0,a
1: call z,?const
replacement:
0: rra
1: call nc,?const
constraints:
regsNotUsedAfter(1,A)

pattern: Replace bit 7,a; call z,?const with rla; call nc,?const
0: bit 7,a
1: call z,?const
replacement:
0: rla
1: call nc,?const
constraints:
regsNotUsedAfter(1,A)

pattern: Replace ld ?regixiy,?const1; ld r,(?regixiy+?const2) with ld hl,?const1+?const2; ld ?reg,(hl)
0: ld ?regixiy,?const1
1: ld ?reg,(?regixiy+?const2)
replacement:
0: ld hl,?const1+?const2
1: ld ?reg,(hl)
constraints:
in(?regixiy,IX,IY)
regsNotUsedAfter(1,?regixiy,HL)

pattern: Replace ld ?regixiy,?const1; ld ?reg,(?regixiy) with ld hl,?const1; ld ?reg,(hl)
0: ld ?regixiy,?const1
1: ld ?reg,(?regixiy)
replacement:
0: ld hl,?const1
1: ld ?reg,(hl)
constraints:
in(?regixiy,IX,IY)
regsNotUsedAfter(1,?regixiy,HL)

pattern: Remove ld ?reg,?reg
0: ld ?reg,?reg
replacement:

; theNestruo
pattern: Replace ld ?reg,?const1; ld (?regixiy+?const2),?reg with ld (?regixiy+?const2),?const1
0: ld ?reg,?const1
1: ld (?regixiy+?const2),?reg
replacement:
0: ld (?regixiy+?const2),?const1
constraints:
in(?regixiy,IX,IY)
regsNotUsedAfter(1,?reg)

; theNestruo
pattern: Replace xor a; ld (?regixiy+?const2),a with ld (?regixiy+?const2),0
0: xor a
1: ld (?regixiy+?const2),a
replacement:
0: ld (?regixiy+?const2),0
constraints:
in(?regixiy,IX,IY)
regsNotUsedAfter(1,A)

; theNestruo
pattern: Replace ld ?regpair,?const1 with ld ?regpairl,(?const1 % 256)
0: ld ?regpair,?const1
replacement:
0: ld ?regpairl,(?const1 % 256)
constraints:
regpair(?regpair,?regpairh,?regpairl)
regsNotUsedAfter(0,?regpairh)

pattern: Replace ld ?regpair,?const1 with ld ?regpairh,(?const1) >> 8
0: ld ?regpair,?const1
replacement:
0: ld ?regpairh,(?const1) >> 8
constraints:
regpair(?regpair,?regpairh,?regpairl)
regsNotUsedAfter(0,?regpairl)

pattern: Remove duplicate ld ?reg,?const
2: ld ?reg,?const
1: *
0: ld ?reg,?const
replacement:
2: ld ?reg,?const
1: *
constraints:
regsNotModified(1, ?reg)

pattern: Remove duplicate ld ?reg1,?reg2
2: ld ?reg1,?reg2
1: *
0: ld ?reg1,?reg2
replacement:
2: ld ?reg1,?reg2
1: *
constraints:
regsNotModified(1, ?reg1, ?reg2)

; Thanks to Metalion/theNestruo for suggesting the idea for this pattern:
pattern: Replace ld ?regpair,?const2 with ld ?regpairl,(?const2) % 256
2: ld ?regpair,?const1 
1: *
0: ld ?regpair,?const2 
replacement:
2: ld ?regpair,?const1 
1: * 
0: ld ?regpairl,(?const2) % 256
constraints:
regsNotModified(1, ?regpair)
regpair(?regpair,?regpairh,?regpairl)
equal((?const1) >> 8, (?const2) >> 8)

; Thanks to theNestruo for suggesting the idea for this pattern:
pattern: Replace ld ?regpair,?const2 with ld ?regpairh,(?const2) >> 8
2: ld ?regpair,?const1 
1: * 
0: ld ?regpair,?const2 
replacement:
2: ld ?regpair,?const1 
1: * 
0: ld ?regpairh,(?const2) >> 8
constraints:
regsNotModified(1, ?regpair)
regpair(?regpair,?regpairh,?regpairl)
equal((?const1) % 256, (?const2) % 256)

; Thanks to theNestruo for suggesting the idea for this pattern:
pattern: Replace ld (?reg2),?const with ld (?reg2),?reg (as ?reg == ?const here)
2: ld ?reg,?const
1: *
0: ld (?reg2),?const
replacement:
2: ld ?reg,?const
1: *
0: ld (?reg2),?reg
constraints:
in(?reg,A,B,C,D,E,H,L)
in(?reg2,HL,IX,IY)
regsNotModified(1,?reg)

; Thanks to theNestruo for suggesting the idea for this pattern:
pattern: Replace ld (?reg2),?const2 with ld (?reg2),?regpairl (as ?regpairl == ?const2 here)
2: ld ?regpair,?const1
1: *
0: ld (?reg2),?const2
replacement:
2: ld ?regpair,?const1
1: *
0: ld (?reg2),?regpairl
constraints:
regpair(?regpair,?regpairh,?regpairl)
in(?reg2,HL,IX,IY)
equal(?const2, (?const1) % 256)
regsNotModified(1,?regpairl)

; Thanks to theNestruo for suggesting the idea for this pattern:
pattern: Replace ld (?reg2),?const2 with ld (?reg2),?regpairh (as ?regpairh == ?const2 here)
2: ld ?regpair,?const1
1: *
0: ld (?reg2),?const2
replacement:
2: ld ?regpair,?const1
1: *
0: ld (?reg2),?regpairh
constraints:
regpair(?regpair,?regpairh,?regpairl)
in(?reg2,HL,IX,IY)
equal(?const2, (?const1) >> 8)
regsNotModified(1,?regpairh)

; Thanks to theNestruo for suggesting the idea for this pattern:
pattern: Replace ld ?reg2,?const with ld ?reg2,?reg (as ?reg == ?const here)
2: ld ?reg,?const
1: *
0: ld ?reg2,?const
replacement:
2: ld ?reg,?const
1: *
0: ld ?reg2,?reg
constraints:
in(?reg,A,B,C,D,E,H,L)
in(?reg2,A,B,C,D,E,H,L)
regsNotModified(1,?reg)

; Thanks to theNestruo for suggesting the idea for this pattern:
pattern: Replace ld ?reg2,?const2 with ld ?reg2,?regpairl (as ?regpairl == ?const2 here)
2: ld ?regpair,?const1
1: *
0: ld ?reg2,?const2
replacement:
2: ld ?regpair,?const1
1: *
0: ld ?reg2,?regpairl
constraints:
regpair(?regpair,?regpairh,?regpairl)
in(?reg2,A,B,C,D,E,H,L)
equal(?const2, ?const1 % 256)
regsNotModified(1,?regpairl)

; Thanks to theNestruo for suggesting the idea for this pattern:
pattern: Replace ld ?reg2,?const2 with ld ?reg2,?regpairh (as ?regpairh == ?const2 here)
2: ld ?regpair,?const1
1: *
0: ld ?reg2,?const2
replacement:
2: ld ?regpair,?const1
1: *
0: ld ?reg2,?regpairh
constraints:
regpair(?regpair,?regpairh,?regpairl)
in(?reg2,A,B,C,D,E,H,L)
equal((?const2) & #ff, (?const1 & #ffff) >> 8)
regsNotModified(1,?regpairh)
