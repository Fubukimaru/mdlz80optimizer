; Author: Santiago Ontañón
; - Patterns are separated by a blank line
; - Patterns suggested by others are credited to them below.
; - If you do a pull request with more patterns, please credit yourself in a comment before the pattern.

; Notes:
; - variables must start with the following prefixes:
; - ?const: for example ?const1, ?constant, etc. These match with constant expressions, like "(VAR+2)/$", or "1".
; - ?reg: for example ?reg1, ?regpair, etc. These match with register names.
; - ?any: for example ?any, ?any1. These match with anything.
; Notice the numbers in front of each line int he pattern and the replacement. The order does not matter as long as numbers are unique.
; These are used to match lines from pattern to replacement. Any number appearing in pattern, and not in replacement will be deleted.
; The optimization will be reported to the line in pattern with number 0 (at least one line must have number 0)

; thanks to pgimeno for noticing the needed constraint
pattern: Replace cp ?const1; jp c,?const2; jp z,?const2 with cp ?const1+1; jp c,?const2
0: cp ?const1
1: jp c,?const2
2: jp z,?const2
replacement:
0: cp ?const1+1
1: jp c,?const2
constraints:
notEqual(?const1,255)

; thanks to pgimeno for noticing the needed constraint
pattern: Replace cp ?const1; jr c,?const2; jr z,?const2 with cp ?const1+1; jr c,?const2
0: cp ?const1
1: jr c,?const2
2: jr z,?const2
replacement:
0: cp ?const1+1
1: jr c,?const2
constraints:
notEqual(?const1,255)

pattern: Replace cp 0 with or a
0: cp 0
replacement:
0: or a

pattern: Replace cp 1 with dec a
0: cp 1
replacement:
0: dec a
constraints:
regsNotUsedAfter(0,A)

pattern: Replace cp 255 with inc a
0: cp 255
replacement:
0: inc a
constraints:
regsNotUsedAfter(0,A)

pattern: Replace ld a,0 with xor a
0: ld a,0
replacement:
0: xor a
constraints:
flagsNotUsedAfter(0,S,Z,H,P/V,N,C)

pattern: Replace srl a; srl a; srl a with rrca; rrca; rrca; and #1f
0: srl a
1: srl a
2: srl a
replacement:
0: rrca
1: rrca
2: rrca
2: and #1f

pattern: Remove unused ld ?reg,?any
0: ld ?reg,?any
replacement:
constraints:
regsNotUsedAfter(0,?reg)

pattern: Replace pop ?regpair1; ld ?regpair2h,?regpair1h; ld ?regpair2l,?regpair1l with pop ?regpair2
0: pop ?regpair1
1: ld ?regpair2h,?regpair1h
2: ld ?regpair2l,?regpair1l
replacement:
0: pop ?regpair2
constraints:
in(?regpair1,BC,DE,HL)
regpair(?regpair1,?regpair1h,?regpair1l)
regpair(?regpair2,?regpair2h,?regpair2l)
in(?regpair2,BC,DE,HL)
regsNotUsedAfter(2,?regpair1)

pattern: Replace pop ?regpair1; ld ?regpair2l,?regpair1l; ld ?regpair2h,?regpair1h with pop ?regpair2
0: pop ?regpair1
2: ld ?regpair2l,?regpair1l
1: ld ?regpair2h,?regpair1h
replacement:
0: pop ?regpair2
constraints:
in(?regpair1,BC,DE,HL)
regpair(?regpair1,?regpair1h,?regpair1l)
regpair(?regpair2,?regpair2h,?regpair2l)
in(?regpair2,BC,DE,HL)
regsNotUsedAfter(2,?regpair1)

pattern: Replace 0: ld a,(?const1); inc a; ld (?const1),a with  ld hl,?const1; inc (hl)
0: ld a,(?const1)
1: inc a
2: ld (?const1),a
replacement:
0: ld hl,?const1
1: inc (hl)
constraints:
regsNotUsedAfter(2,A,HL)

pattern: Replace ld a,(?const1); inc a; ld (?const1),a with  ld hl,?const1; inc (hl); ld a,(hl)
0: ld a,(?const1)
1: inc a
2: ld (?const1),a
replacement:
0: ld hl,?const1
1: inc (hl)
2: ld a,(hl)
constraints:
regsNotUsedAfter(2,HL)


pattern: Replace 0: ld a,(?const1); dec a; ld (?const1),a with  ld hl,?const1; dec (hl)
0: ld a,(?const1)
1: dec a
2: ld (?const1),a
replacement:
0: ld hl,?const1
1: dec (hl)
constraints:
regsNotUsedAfter(2,A,HL)

pattern: Replace ld a,(?const1); dec a; ld (?const1),a with  ld hl,?const1; dec (hl); ld a,(hl)
0: ld a,(?const1)
1: dec a
2: ld (?const1),a
replacement:
0: ld hl,?const1
1: dec (hl)
2: ld a,(hl)
constraints:
regsNotUsedAfter(2,HL)


pattern: Replace ld ?regpair1h,?const1; ld ?regpair1l,?const2 with ld ?regpair1,((?const2) & #ff) + ((?const1) << 8)
0: ld ?regpair1h,?const1
1: *
2: ld ?regpair1l,?const2
replacement:
0: ld ?regpair1,((?const2) & #ff) + ((?const1) << 8)
1: *
constraints:
regpair(?regpair1,?regpair1h,?regpair1l)
regsNotUsed(1,?regpair1h)

pattern: Replace ld ?regpair1l,?const2; ld ?regpair1h,?const1 with ld ?regpair1,((?const2) & #ff) + ((?const1) << 8)
0: ld ?regpair1l,?const2
1: *
2: ld ?regpair1h,?const1
replacement:
0: ld ?regpair1,((?const2) & #ff) + ((?const1) << 8)
1: *
constraints:
regpair(?regpair1,?regpair1h,?regpair1l)
regsNotUsed(1,?regpair1l)

pattern: Replace ld a,?const1; ld (hl),a with ld (hl),?const1
0: ld a,?const1
1: *
2: ld (hl),a
replacement:
0: ld (hl),?const1
1: *
constraints:
regsNotUsedAfter(2,A)
regsNotUsed(1,A)

pattern: Replace dec b; jr nz,label with djnz label
0: dec b
1: jr nz,?const1
replacement:
0: djnz ?const1

pattern: Replace ld a,(hl); lde (de),a; inc hl; inc de with ldi
0: ld a,(hl)
1: ld (de),a
2: inc hl
3: inc de
replacement:
0: ldi
constraints:
regsNotUsedAfter(3,A,BC)

; thanks to pgimeno for suggesting this permutation
pattern: Replace ld a,(hl); inc hl; lde (de),a; inc de with ldi
0: ld a,(hl)
2: inc hl
1: ld (de),a
3: inc de
replacement:
0: ldi
constraints:
regsNotUsedAfter(3,A,BC)

pattern: Replace ld a,(hl); ld (de),a; inc de; inc hl; with ldi
0: ld a,(hl)
1: ld (de),a
3: inc de
2: inc hl
replacement:
0: ldi
constraints:
regsNotUsedAfter(3,A,BC)

pattern: Replace ld a,(hl); lde (de),a; inc hl; inc de with ldi; inc bc
0: ld a,(hl)
1: ld (de),a
2: inc hl
3: inc de
replacement:
0: ldi
1: inc bc
constraints:
regsNotUsedAfter(3,A)

; thanks to pgimeno for suggesting this permutation
pattern: Replace ld a,(hl); inc hl; lde (de),a; inc de with ldi; inc bc
0: ld a,(hl)
2: inc hl
1: ld (de),a
3: inc de
replacement:
0: ldi
1: inc bc
constraints:
regsNotUsedAfter(3,A)

pattern: Replace ld a,(hl); lde (de),a; inc de; inc hl; with ldi
0: ld a,(hl)
1: ld (de),a
3: inc de
2: inc hl
replacement:
0: ldi
1: inc bc
constraints:
regsNotUsedAfter(3,A)

pattern: Replace ld ?regpair,?const1; or a; sbc hl,?regpair with ld ?regpair,-(?const1); add hl,?regpair
0: ld ?regpair,?const1
1: or a
2: sbc hl,?regpair
replacement:
0: ld ?regpair,-(?const1)
1: add hl,?regpair
constraints:
in(?regpair,BC,DE)
flagsNotUsedAfter(2,S,Z,P/V,N)

; thanks to grauw for suggesting this variation
pattern: Replace ld ?regpair,?const1; and a; sbc hl,?regpair with ld ?regpair,-(?const1); add hl,?regpair
0: ld ?regpair,?const1
1: and a
2: sbc hl,?regpair
replacement:
0: ld ?regpair,-(?const1)
1: add hl,?regpair
constraints:
in(?regpair,BC,DE)
flagsNotUsedAfter(2,S,Z,P/V,N)

pattern: Replace neg; add a,?const1 with cpl; add a,?const1+1
0: neg
1: add a,?const1
replacement:
0: cpl
1: add a,?const1+1

pattern: Replace xor 255 with cpl
0: xor 255
replacement:
0: cpl
constraints:
flagsNotUsedAfter(0,S,Z,P/V,C)

pattern: Replace ld a,?reg; neg with xor a; sub ?reg
0: ld a,?reg
1: neg
replacement:
0: xor a
1: sub ?reg

pattern: Replace ld a,?reg; sub ?const; neg with ld a,?const; sub ?reg
0: ld a,?reg
1: sub ?const
2: neg
replacement:
0: ld a,?const
1: sub ?reg

pattern: Replace sla l; rl h with add hl,hl
0: sla l
1: rl h
replacement:
0: add hl,hl
constraints:
flagsNotUsedAfter(1,S,Z,P/V,C)

; thanks to grauw for suggesting this pattern
pattern: Replace sla a with add a,a
0: sla a
replacement:
0: add a,a
constraints:
flagsNotUsedAfter(0,H,P/V)

; theNestruo
pattern: Replace call ?const; ret with jp ?const
0: call ?const
1: ret
replacement:
0: jp ?const

pattern: Replace and 1; cp 1; jr z,?const with rra; jr nz,?const
0: and 1
1: cp 1
2: jr z,?const
replacement:
0: rra
1: jr c,?const
constraints:
regsNotUsedAfter(2,A)

pattern: Replace and 1; cp 1; jp z,?const with rra; jp nz,?const
0: and 1
1: cp 1
2: jp z,?const
replacement:
0: rra
1: jp c,?const
constraints:
regsNotUsedAfter(2,A)

pattern: Replace and 1; cp 1; call z,?const with rra; call nz,?const
0: and 1
1: cp 1
2: call z,?const
replacement:
0: rra
1: call c,?const
constraints:
regsNotUsedAfter(2,A)

pattern: Replace and 1; cp 1; jr z,?const with and 1; jr nz,?const
0: and 1
1: cp 1
2: jr z,?const
replacement:
0: and 1
1: jr nz,?const

pattern: Replace and 1; cp 1; jp z,?const with and 1; jp nz,?const
0: and 1
1: cp 1
2: jp z,?const
replacement:
0: and 1
1: jp nz,?const

pattern: Replace and 1; cp 1; call z,?const with and 1; call nz,?const
0: and 1
1: cp 1
2: call z,?const
replacement:
0: and 1
1: call nz,?const

pattern: Replace bit 0,a; jr z,?const with rra; jr nc,?const
0: bit 0,a
1: jr z,?const
replacement:
0: rra
1: jr nc,?const
constraints:
regsNotUsedAfter(1,A)

pattern: Replace bit 0,a; jp z,?const with rra; jp nc,?const
0: bit 0,a
1: jp z,?const
replacement:
0: rra
1: jp nc,?const
constraints:
regsNotUsedAfter(1,A)

pattern: Replace bit 0,a; call z,?const with rra; call nc,?const
0: bit 0,a
1: call z,?const
replacement:
0: rra
1: call nc,?const
constraints:
regsNotUsedAfter(1,A)

pattern: Replace bit 0,a; jr nz,?const with rra; jr c,?const
0: bit 0,a
1: jr nz,?const
replacement:
0: rra
1: jr c,?const
constraints:
regsNotUsedAfter(1,A)

pattern: Replace bit 0,a; jp nz,?const with rra; jp c,?const
0: bit 0,a
1: jp nz,?const
replacement:
0: rra
1: jp c,?const
constraints:
regsNotUsedAfter(1,A)

pattern: Replace bit 0,a; call nz,?const with rra; call c,?const
0: bit 0,a
1: call nz,?const
replacement:
0: rra
1: call c,?const
constraints:
regsNotUsedAfter(1,A)

pattern: Replace bit 7,a; jr z,?const with rla; jr nc,?const
0: bit 7,a
1: jr z,?const
replacement:
0: rla
1: jr nc,?const
constraints:
regsNotUsedAfter(1,A)

pattern: Replace bit 7,a; jp z,?const with rla; jp nc,?const
0: bit 7,a
1: jp z,?const
replacement:
0: rla
1: jp nc,?const
constraints:
regsNotUsedAfter(1,A)

pattern: Replace bit 7,a; call z,?const with rla; call nc,?const
0: bit 7,a
1: call z,?const
replacement:
0: rla
1: call nc,?const
constraints:
regsNotUsedAfter(1,A)

pattern: Replace bit 7,a; jr nz,?const with rla; jr c,?const
0: bit 7,a
1: jr nz,?const
replacement:
0: rla
1: jr c,?const
constraints:
regsNotUsedAfter(1,A)

pattern: Replace bit 7,a; jp nz,?const with rla; jp c,?const
0: bit 7,a
1: jp nz,?const
replacement:
0: rla
1: jp c,?const
constraints:
regsNotUsedAfter(1,A)

pattern: Replace bit 7,a; call nz,?const with rla; call c,?const
0: bit 7,a
1: call nz,?const
replacement:
0: rla
1: call c,?const
constraints:
regsNotUsedAfter(1,A)

pattern: Replace ld ?regixiy,?const1; ld ?reg,(?regixiy+?const2) with ld hl,?const1+?const2; ld ?reg,(hl)
0: ld ?regixiy,?const1
1: ld ?reg,(?regixiy+?const2)
replacement:
0: ld hl,?const1+?const2
1: ld ?reg,(hl)
constraints:
in(?regixiy,IX,IY)
regsNotUsedAfter(1,?regixiy,HL)

pattern: Replace ld ?regixiy,?const1; ld ?reg,(?regixiy) with ld hl,?const1; ld ?reg,(hl)
0: ld ?regixiy,?const1
1: ld ?reg,(?regixiy)
replacement:
0: ld hl,?const1
1: ld ?reg,(hl)
constraints:
in(?regixiy,IX,IY)
regsNotUsedAfter(1,?regixiy,HL)

pattern: Replace ld ?regixiy,?const1; ld (?regixiy+?const2),?const3 with ld hl,?const1+?const2; ld (hl),?const3
0: ld ?regixiy,?const1
1: ld (?regixiy+?const2),?const3
replacement:
0: ld hl,?const1+?const2
1: ld (hl),?const3
constraints:
in(?regixiy,IX,IY)
regsNotUsedAfter(1,?regixiy,HL)

pattern: Replace ld ?regixiy,?const1; ld (?regixiy),?const3 with ld hl,?const1; ld (hl),?const3
0: ld ?regixiy,?const1
1: ld (?regixiy),?const3
replacement:
0: ld hl,?const1
1: ld (hl),?const3
constraints:
in(?regixiy,IX,IY)
regsNotUsedAfter(1,?regixiy,HL)

pattern: Replace ld ?regixiy,?const1; ld ?reg1,(?regixiy+?const2); ld ?reg2,(?regixiy+?const3) with ld hl,?const1+?const2; ld ?reg1,(hl); inc hl; ld ?reg2,(hl)
0: ld ?regixiy,?const1
1: ld ?reg1,(?regixiy+?const2)
2: ld ?reg2,(?regixiy+?const3)
replacement:
0: ld hl,?const1+?const2
1: ld ?reg1,(hl)
2: inc hl
3: ld ?reg2,(hl)
constraints:
in(?regixiy,IX,IY)
regsNotUsedAfter(2,?regixiy,HL)
notIn(?reg1,H,L)
notIn(?reg2,H,L)
equal(?const2+1,?const3)

pattern: Replace ld ?regixiy,?const1; ld ?reg1,(?regixiy); ld ?reg2,(?regixiy+1) with ld hl,?const1; ld ?reg1,(hl); inc hl; ld ?reg2,(hl)
0: ld ?regixiy,?const1
1: ld ?reg1,(?regixiy)
2: ld ?reg2,(?regixiy+1)
replacement:
0: ld hl,?const1
1: ld ?reg1,(hl)
2: inc hl
3: ld ?reg2,(hl)
constraints:
in(?regixiy,IX,IY)
regsNotUsedAfter(2,?regixiy,HL)
notIn(?reg1,H,L)
notIn(?reg2,H,L)

pattern: Remove ld ?reg,?reg
0: ld ?reg,?reg
replacement:

; theNestruo
pattern: Replace ld ?reg,?const1; ld (?regixiy+?const2),?reg with ld (?regixiy+?const2),?const1
0: ld ?reg,?const1
1: ld (?regixiy+?const2),?reg
replacement:
0: ld (?regixiy+?const2),?const1
constraints:
in(?regixiy,IX,IY)
regsNotUsedAfter(1,?reg)

; theNestruo
pattern: Replace xor a; ld (?regixiy+?const2),a with ld (?regixiy+?const2),0
0: xor a
1: ld (?regixiy+?const2),a
replacement:
0: ld (?regixiy+?const2),0
constraints:
in(?regixiy,IX,IY)
regsNotUsedAfter(1,A)

; theNestruo
pattern: Replace ld ?regpair,?const1 with ld ?regpairl,(?const1 % 256)
0: ld ?regpair,?const1
replacement:
0: ld ?regpairl,(?const1 % 256)
constraints:
regpair(?regpair,?regpairh,?regpairl)
regsNotUsedAfter(0,?regpairh)

pattern: Replace ld ?regpair,?const1 with ld ?regpairh,(?const1) >> 8
0: ld ?regpair,?const1
replacement:
0: ld ?regpairh,(?const1) >> 8
constraints:
regpair(?regpair,?regpairh,?regpairl)
regsNotUsedAfter(0,?regpairl)

pattern: Remove duplicate ld ?reg,?const
2: ld ?reg,?const
1: *
0: ld ?reg,?const
replacement:
2: ld ?reg,?const
1: *
constraints:
regsNotModified(1, ?reg)

pattern: Remove duplicate ld ?reg1,?reg2
2: ld ?reg1,?reg2
1: *
0: ld ?reg1,?reg2
replacement:
2: ld ?reg1,?reg2
1: *
constraints:
regsNotModified(1, ?reg1, ?reg2)

; Thanks to Metalion/theNestruo for suggesting the idea for this pattern:
pattern: Replace ld ?regpair,?const2 with ld ?regpairl,(?const2) & #00ff
2: ld ?regpair,?const1 
1: *
0: ld ?regpair,?const2 
replacement:
2: ld ?regpair,?const1 
1: * 
0: ld ?regpairl,(?const2) & #00ff
constraints:
regsNotModified(1, ?regpair)
regpair(?regpair,?regpairh,?regpairl)
equal((?const1) & #ff00, (?const2) & #ff00)

; Thanks to theNestruo for suggesting the idea for this pattern:
pattern: Replace ld ?regpair,?const2 with ld ?regpairh,(?const2) >> 8
2: ld ?regpair,?const1 
1: * 
0: ld ?regpair,?const2 
replacement:
2: ld ?regpair,?const1 
1: * 
0: ld ?regpairh,(?const2) >> 8
constraints:
regsNotModified(1, ?regpair)
regpair(?regpair,?regpairh,?regpairl)
equal((?const1) & #00ff, (?const2) & #00ff)

; Thanks to theNestruo for suggesting the idea for this pattern:
pattern: Replace ld (?reg2),?const with ld (?reg2),?reg (as ?reg == ?const here)
2: ld ?reg,?const
1: *
0: ld (?reg2),?const
replacement:
2: ld ?reg,?const
1: *
0: ld (?reg2),?reg
constraints:
in(?reg,A,B,C,D,E,H,L)
in(?reg2,HL,IX,IY)
regsNotModified(1,?reg)

; Thanks to theNestruo for suggesting the idea for this pattern:
pattern: Replace ld (?reg2),?const2 with ld (?reg2),?regpairl (as ?regpairl == ?const2 here)
2: ld ?regpair,?const1
1: *
0: ld (?reg2),?const2
replacement:
2: ld ?regpair,?const1
1: *
0: ld (?reg2),?regpairl
constraints:
regpair(?regpair,?regpairh,?regpairl)
in(?reg2,HL,IX,IY)
equal(?const2, (?const1) & #00ff)
regsNotModified(1,?regpairl)

; Thanks to theNestruo for suggesting the idea for this pattern:
pattern: Replace ld (?reg2),?const2 with ld (?reg2),?regpairh (as ?regpairh == ?const2 here)
2: ld ?regpair,?const1
1: *
0: ld (?reg2),?const2
replacement:
2: ld ?regpair,?const1
1: *
0: ld (?reg2),?regpairh
constraints:
regpair(?regpair,?regpairh,?regpairl)
in(?reg2,HL,IX,IY)
equal(?const2, (?const1) >> 8)
regsNotModified(1,?regpairh)

; Thanks to theNestruo for suggesting the idea for this pattern:
pattern: Replace ld ?reg2,?const with ld ?reg2,?reg (as ?reg == ?const here)
2: ld ?reg,?const
1: *
0: ld ?reg2,?const
replacement:
2: ld ?reg,?const
1: *
0: ld ?reg2,?reg
constraints:
in(?reg,A,B,C,D,E,H,L)
in(?reg2,A,B,C,D,E,H,L)
regsNotModified(1,?reg)

; Thanks to theNestruo for suggesting the idea for this pattern:
pattern: Replace ld ?reg2,?const2 with ld ?reg2,?regpairl (as ?regpairl == ?const2 here)
2: ld ?regpair,?const1
1: *
0: ld ?reg2,?const2
replacement:
2: ld ?regpair,?const1
1: *
0: ld ?reg2,?regpairl
constraints:
regpair(?regpair,?regpairh,?regpairl)
in(?reg2,A,B,C,D,E,H,L)
equal(?const2, (?const1) & #00ff)
regsNotModified(1,?regpairl)

; Thanks to theNestruo for suggesting the idea for this pattern:
pattern: Replace ld ?reg2,?const2 with ld ?reg2,?regpairh (as ?regpairh == ?const2 here)
2: ld ?regpair,?const1
1: *
0: ld ?reg2,?const2
replacement:
2: ld ?regpair,?const1
1: *
0: ld ?reg2,?regpairh
constraints:
regpair(?regpair,?regpairh,?regpairl)
in(?reg2,A,B,C,D,E,H,L)
equal((?const2) & #ff, (?const1 & #ffff) >> 8)
regsNotModified(1,?regpairh)

; Thanks to Jitursan for suggesting this pattern:
pattern: Replace inc hl; dec bc; ld a,?reg1; or ?reg2; jr nz,?const with cpi; jp pe,?const
0: inc hl
1: *
2: dec bc
3: ld a,?reg1
4: or ?reg2
5: jr nz,?const
replacement:
1: *
2: cpi
5: jp pe,?const
constraints:
in(?reg1,B,C)
in(?reg2,C,B)
notEqual(?reg1,?reg2)
flagsNotUsedAfter(5,S,Z,H,P/V,N,C)
regsNotUsedAfter(5,A)
regsNotUsed(1,HL)
regsNotModified(1,HL)

; Thanks to Artrag for this variation:
pattern: Replace dec hl; dec bc; ld a,?reg1; or ?reg2; jr nz,?const with cpd; jp pe,?const
0: dec ?regpair1
1: *
2: dec ?regpair2
3: ld a,?reg1
4: or ?reg2
5: jr nz,?const
replacement:
1: *
2: cpd
5: jp pe,?const
constraints:
in(?regpair1,BC,HL)
in(?regpair2,BC,HL)
in(?reg1,B,C)
in(?reg2,C,B)
notEqual(?reg1,?reg2)
notEqual(?regpair1,?regpair2)
flagsNotUsedAfter(5,S,Z,H,P/V,N,C)
regsNotUsedAfter(5,A)
regsNotUsed(1,HL)
regsNotModified(1,HL)

; Note that we include the "atLeastOneCPUOp" constraint, to prevent eliminating the usual push af; pop af combination used for timing
pattern: Remove push ?reg / pop ?reg as register is not modified in between
0: push ?reg
1: *
2: pop ?reg
replacement:
1: *
constraints:
regsNotModified(1,?reg)
evenPushPops(1)
atLeastOneCPUOp(1)

; Note that we include the "atLeastOneCPUOp" constraint, to prevent eliminating the usual push af; pop af combination used for timing
pattern: Remove push ?reg / pop ?reg as register is not used afterwards
0: push ?reg
1: *
2: pop ?reg
replacement:
1: *
constraints:
regsNotUsedAfter(2,?reg)
evenPushPops(1)
atLeastOneCPUOp(1)

; Thanks to theNestruo for suggesting the idea for this pattern:
pattern: Remove unnecessary xor a (a must be zero here)
1: or a
2: jr nz,?const
3: *
0: xor a
replacement:
1: or a
2: jr nz,?const
3: *
constraints:
regsNotModified(3,A)

; Thanks to theNestruo for suggesting the idea for this pattern:
pattern: Remove unnecessary xor a (a must be 0 here)
1: or a
2: jp nz,?const
3: *
0: xor a
replacement:
1: or a
2: jp nz,?const
3: *
constraints:
regsNotModified(3,A)

; Thanks to theNestruo for suggesting the idea for this pattern:
pattern: Remove unnecessary ld a,0 (a must be zero here)
1: or a
2: jr nz,?const
3: *
0: ld a,0
replacement:
1: or a
2: jr nz,?const
3: *
constraints:
regsNotModified(3,A)

; Thanks to theNestruo for suggesting the idea for this pattern:
pattern: Remove unnecessary ld a,0 (a must be 0 here)
1: or a
2: jp nz,?const
3: *
0: ld a,0
replacement:
1: or a
2: jp nz,?const
3: *
constraints:
regsNotModified(3,A)

; Thanks to theNestruo for suggesting the idea for this pattern:
pattern: Remove unnecessary ld b,0 (b must be 0 here)
1: djnz ?const
2: *
0: ld b,0
replacement:
1: djnz ?const
2: *
constraints:
regsNotModified(2,B)

pattern: Replace dec a; add a, ?const with add a, (?const)-1
0: dec a
1: add a, ?const
replacement:
1: add a, (?const)-1

pattern: Replace inc a; add a, ?const with add a, (?const)+1
0: inc a
1: add a, ?const
replacement:
1: add a, (?const)+1

pattern: Replace add a,?const with inc a
0: add a,?const
replacement:
0: inc a
constraints:
equal(?const,1)

pattern: Replace add a,?const with dec a
0: add a,?const
replacement:
0: dec a
constraints:
equal(?const,-1)

pattern: Replace add a,?const with add a,?reg (as ?reg == ?const here)
2: ld ?reg,?const
1: *
0: add a,?const
replacement:
2: ld ?reg,?const
1: *
0: add a,?reg
constraints:
in(?reg,A,B,C,D,E,H,L)
regsNotModified(1,?reg)

pattern: Replace sub ?const with sub ?reg (as ?reg == ?const here)
2: ld ?reg,?const
1: *
0: sub ?const
replacement:
2: ld ?reg,?const
1: *
0: sub ?reg
constraints:
in(?reg,A,B,C,D,E,H,L)
regsNotModified(1,?reg)

pattern: Replace and ?const with and ?reg (as ?reg == ?const here)
2: ld ?reg,?const
1: *
0: and ?const
replacement:
2: ld ?reg,?const
1: *
0: and ?reg
constraints:
in(?reg,A,B,C,D,E,H,L)
regsNotModified(1,?reg)

pattern: Replace or ?const with or ?reg (as ?reg == ?const here)
2: ld ?reg,?const
1: *
0: or ?const
replacement:
2: ld ?reg,?const
1: *
0: or ?reg
constraints:
in(?reg,A,B,C,D,E,H,L)
regsNotModified(1,?reg)

pattern: Replace add a,?const with add a,?regl (as ?regl == ?const2 here)
2: ld ?regpair,?const1
1: *
0: add a,?const2
replacement:
2: ld ?regpair,?const1
1: *
0: add a,?regl
constraints:
regpair(?regpair,?regh,?regl)
in(?regpair,HL,BC,DE)
regsNotModified(1,?regl)
equal(?const1&#ff,const2)

pattern: Replace sub ?const with sub ?regl (as ?regl == ?const2 here)
2: ld ?regpair,?const1
1: *
0: sub ?const2
replacement:
2: ld ?regpair,?const1
1: *
0: sub ?regl
constraints:
regpair(?regpair,?regh,?regl)
in(?regpair,HL,BC,DE)
regsNotModified(1,?regl)
equal(?const1&#ff,const2)

pattern: Replace and ?const with and ?regl (as ?regl == ?const2 here)
2: ld ?regpair,?const1
1: *
0: and ?const2
replacement:
2: ld ?regpair,?const1
1: *
0: and ?regl
constraints:
regpair(?regpair,?regh,?regl)
in(?regpair,HL,BC,DE)
regsNotModified(1,?regl)
equal(?const1&#ff,const2)

pattern: Replace or ?const with or ?regl (as ?regl == ?const2 here)
2: ld ?regpair,?const1
1: *
0: or ?const2
replacement:
2: ld ?regpair,?const1
1: *
0: or ?regl
constraints:
regpair(?regpair,?regh,?regl)
in(?regpair,HL,BC,DE)
regsNotModified(1,?regl)
equal(?const1&#ff,const2)

pattern: Replace add a,?const2 with add a,?regh (as ?regh == ?const2 here)
2: ld ?regpair,?const1
1: *
0: add a,?const2
replacement:
2: ld ?regpair,?const
1: *
0: add a,?regh
constraints:
regpair(?regpair,?regh,?regl)
in(?regpair,HL,BC,DE)
regsNotModified(1,?regh)
equal((?const1&#ff00)>>8,const2)

pattern: Replace sub ?const2 with sub ?regh (as ?regh == ?const2 here)
2: ld ?regpair,?const1
1: *
0: sub ?const2
replacement:
2: ld ?regpair,?const1
1: *
0: sub ?regh
constraints:
regpair(?regpair,?regh,?regl)
in(?regpair,HL,BC,DE)
regsNotModified(1,?regh)
equal((?const1&#ff00)>>8,const2)

pattern: Replace and ?const2 with and ?regh (as ?regh == ?const2 here)
2: ld ?regpair,?const1
1: *
0: and ?const2
replacement:
2: ld ?regpair,?const1
1: *
0: and ?regh
constraints:
regpair(?regpair,?regh,?regl)
in(?regpair,HL,BC,DE)
regsNotModified(1,?regh)
equal((?const1&#ff00)>>8,const2)

pattern: Replace or ?const2 with or ?regh (as ?regh == ?const2 here)
2: ld ?regpair,?const1
1: *
0: or ?const2
replacement:
2: ld ?regpair,?const1
1: *
0: or ?regh
constraints:
regpair(?regpair,?regh,?regl)
in(?regpair,HL,BC,DE)
regsNotModified(1,?regh)
equal((?const1&#ff00)>>8,const2)

pattern: Replace ld ?regpair,?const2 with ld ?regpairh,?reg; ld ?regpairl,?reg (as ?Reg == ?const1 here)
2: ld ?reg,?const1
1: *
0: ld ?regpair,?const2
replacement:
2: ld ?reg,?const1
1: *
0: ld ?regpairh,?reg
3: ld ?regpairl,?reg
constraints:
in(?reg,A,B,C,D,E,H,L)
regpair(?regpair,?regpairl,?regpairh)
in(?regpair,HL,DE,BC)
equal(?const2,(?const1&#ff)*256+(?const1&#ff))

pattern: Replace ld a,(?const); and ?any; ld (?const),a with ld hl,?const; ld a,(hl); and ?any; ld (hl),a
0: ld a,(?const)
1: and ?any
2: ld (?const),a
replacement:
0: ld hl,?const
1: ld a,(hl)
2: and ?any
3: ld (hl),a
constraints:
regsNotUsedAfter(0,HL)

; The following two patterns are alternatives to the one above, in case the one above does not match:
pattern: Replace ld a,(?const); and ?any; ld (?const),a with ld de,?const; ld a,(de); and ?any; ld (de),a
0: ld a,(?const)
1: and ?any
2: ld (?const),a
replacement:
0: ld de,?const
1: ld a,(de)
2: and ?any
3: ld (de),a
constraints:
regsNotUsedAfter(0,DE)

pattern: Replace ld a,(?const); and ?any; ld (?const),a with ld bc,?const; ld a,(bc); and ?any; ld (bc),a
0: ld a,(?const)
1: and ?any
2: ld (?const),a
replacement:
0: ld bc,?const
1: ld a,(bc)
2: and ?any
3: ld (bc),a
constraints:
regsNotUsedAfter(0,BC)

pattern: Replace ld a,(?const); or ?any; ld (?const),a with ld hl,?const; ld a,(hl); or ?any; ld (hl),a
0: ld a,(?const)
1: or ?any
2: ld (?const),a
replacement:
0: ld hl,?const
1: ld a,(hl)
2: or ?any
3: ld (hl),a
constraints:
regsNotUsedAfter(0,HL)

; The following two patterns are alternatives to the one above, in case the one above does not match:
pattern: Replace ld a,(?const); or ?any; ld (?const),a with ld de,?const; ld a,(de); or ?any; ld (de),a
0: ld a,(?const)
1: or ?any
2: ld (?const),a
replacement:
0: ld de,?const
1: ld a,(de)
2: or ?any
3: ld (de),a
constraints:
regsNotUsedAfter(0,DE)

pattern: Replace ld a,(?const); and ?any; ld (?const),a with ld bc,?const; ld a,(bc); and ?any; ld (bc),a
0: ld a,(?const)
1: or ?any
2: ld (?const),a
replacement:
0: ld bc,?const
1: ld a,(bc)
2: or ?any
3: ld (bc),a
constraints:
regsNotUsedAfter(0,BC)

pattern: Replace ld a,(?const); xor ?any; ld (?const),a with ld hl,?const; ld a,(hl); xor ?any; ld (hl),a
0: ld a,(?const)
1: xor ?any
2: ld (?const),a
replacement:
0: ld hl,?const
1: ld a,(hl)
2: xor ?any
3: ld (hl),a
constraints:
regsNotUsedAfter(0,HL)

; The following two patterns are alternatives to the one above, in case the one above does not match:
pattern: Replace ld a,(?const); xor ?any; ld (?const),a with ld de,?const; ld a,(de); xor ?any; ld (de),a
0: ld a,(?const)
1: xor ?any
2: ld (?const),a
replacement:
0: ld de,?const
1: ld a,(de)
2: xor ?any
3: ld (de),a
constraints:
regsNotUsedAfter(0,DE)

pattern: Replace ld a,(?const); xor ?any; ld (?const),a with ld bc,?const; ld a,(bc); xor ?any; ld (bc),a
0: ld a,(?const)
1: xor ?any
2: ld (?const),a
replacement:
0: ld bc,?const
1: ld a,(bc)
2: xor ?any
3: ld (bc),a
constraints:
regsNotUsedAfter(0,BC)

pattern: Replace push de; ld de, ?const1; add hl, de; pop de with ld bc, ?const1; add hl, bc
0: push de
1: ld de, ?const1
2: add hl, de
3: pop de
replacement:
1: ld bc, ?const1
2: add hl, bc
constraints:
regsNotUsedAfter(3,BC)

pattern: Replace push bc; ld bc, ?const1; add hl, bc; pop bc with ld de, ?const1; add hl, de
0: push bc
1: ld bc, ?const1
2: add hl, bc
3: pop bc
replacement:
1: ld de, ?const1
2: add hl, de
constraints:
regsNotUsedAfter(3,DE)

pattern: Replace inc ?reg; ... inc ?reg with ld a,?reg; add a,?const; ld ?reg,a
0: [?const] inc ?reg
replacement:
0: ld a,?reg
1: add a,?const
2: ld ?reg,a
constraints:
in(?reg,B,C,D,E,H,L,IXL,IYL)
regsNotUsedAfter(0,A)
equal(?const >= 4, -1) 

pattern: Replace inc ?regixiy; ... inc ?regixiy with push bc; ld bc,?const; add ?regixiy,bc; pop bc
0: [?const] inc ?regixiy
replacement:
0: push bc
1: ld bc,?const
2: add ?regixiy,bc
3: pop bc
constraints:
in(?regixiy,IX,IY)
equal(?const >= 5, -1) 

pattern: Replace dec ?regixiy; ... dec ?regixiy with push bc; ld bc,-?const; add ?regixiy,bc; pop bc
0: [?const] dec ?regixiy
replacement:
0: push bc
1: ld bc,-?const
2: add ?regixiy,bc
3: pop bc
constraints:
in(?regixiy,IX,IY)
equal(?const >= 5, -1) 

pattern: Replace inc a; ... inc a with add a,?const
0: [?const] inc a
replacement:
0: add a,?const
constraints:
equal(?const >= 2, -1) 

pattern: Replace dec a; ... dec a with add a,-?const
0: [?const] dec a
replacement:
0: add a,-?const
constraints:
equal(?const >= 2, -1) 

pattern: Replace scf; ccf with or a
0: scf
1: ccf
replacement:
0: or a

pattern: Replace push ?regpair1; pop ?regpair2 with ld ?reg2h,?reg1h; ld ?reg2l,?reg1l
0: push ?regpair1
1: pop ?regpair2
replacement:
0: ld ?reg2h,?reg1h
1: ld ?reg2l,?reg1l
constraints:
in(?regpair1,BC,DE,HL)
in(?regpair2,BC,DE,HL)
regpair(?regpair1,?reg1h,?reg1l)
regpair(?regpair2,?reg2h,?reg2l)
